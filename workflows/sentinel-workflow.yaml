# DEPRECATED (gelato branch)
# This file is the legacy Chainlink CRE workflow spec kept for reference.
# The gelato branch uses Gelato Automate instead. See:
# - workflows/gelato-automate.md
# - docs/gelato_automate.md

# Sentinel Multi-Pool Liquidity Manager - Chainlink CRE Workflow (legacy)
# This workflow orchestrates automated liquidity rebalancing across ALL Uniswap v4 pools
# that use the SentinelHook

name: sentinel-multi-pool-manager
description: Trust-minimized agentic liquidity management with per-pool optimization
version: 2.0.0

# ==============================================================================
# NETWORK CONFIGURATION
# ==============================================================================
network:
  chain: base-mainnet
  chainId: 8453

# ==============================================================================
# CONTRACT ADDRESSES (Base Mainnet)
# ==============================================================================
contracts:
  sentinelHook: "0x0000000000000000000000000000000000000000"  # TODO: Update after deployment
  poolManager: "0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865"   # Uniswap v4 PoolManager
  aavePool: "0xA238Dd80C259a72e81d7e4664a9801593F98d1c5"      # Aave v3 Pool

# ==============================================================================
# ORACLE DATA SOURCES (Base Chainlink Feeds)
# Note: Each pool has its own oracle configured in PoolState
# ==============================================================================
dataSources:
  chainlink:
    - name: eth-usd
      address: "0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70"
      description: "ETH/USD price feed on Base"
    - name: usdc-usd
      address: "0x7e860098F58bBFC8648a4311b374B1D669a2bc6B"
      description: "USDC/USD price feed on Base"
    - name: btc-usd
      address: "0xCCADC697c55bbB68dc5bCdf8d3CBe83CdD4E071E"
      description: "BTC/USD price feed on Base"
    - name: arb-usd
      address: "0x0000000000000000000000000000000000000000"  # TODO: Add ARB oracle
      description: "ARB/USD price feed on Base"

# ==============================================================================
# WORKFLOW DEFINITION - MULTI-POOL EVENT-DRIVEN
# ==============================================================================
workflow:
  # ============================================================================
  # TRIGGER: Monitor for TickCrossed events from ANY pool using SentinelHook
  # ============================================================================
  trigger:
    type: event
    contract: "${contracts.sentinelHook}"
    event: TickCrossed
    abi:
      - "event TickCrossed(bytes32 indexed poolId, int24 tickLower, int24 tickUpper, int24 indexed currentTick)"
    description: "Triggered when price crosses outside the active range in ANY Sentinel pool"
    
    # Fallback: periodic health check for ALL registered pools
    fallback:
      type: cron
      schedule: "0 */4 * * *"  # Every 4 hours
      description: "Periodic check for yield optimization opportunities across all pools"

  # ============================================================================
  # WORKFLOW STEPS
  # ============================================================================
  steps:
    # ==========================================================================
    # STEP 1: Fetch Pool-Specific Configuration
    # ==========================================================================
    - name: get_pool_state
      type: read_contract
      contract: "${contracts.sentinelHook}"
      function: "getPoolState"
      args:
        poolId: "${trigger.poolId}"
      output: poolState
      description: "Get pool-specific configuration (oracle, yield currency, current range)"

    - name: get_pool_tokens
      type: read_contract
      contract: "${contracts.poolManager}"
      function: "getPoolTokens"
      args:
        poolId: "${trigger.poolId}"
      output: poolTokens
      description: "Get the token addresses for this pool"

    # ==========================================================================
    # STEP 2: Fetch Market Data for This Pool's Assets
    # ==========================================================================
    - name: get_chainlink_price
      type: read_contract
      contract: "${poolState.priceFeed}"
      function: "latestRoundData"
      output: oracleData
      description: "Get authoritative price from pool's configured Chainlink oracle"

    - name: fetch_market_volatility
      type: http_request
      method: GET
      url: "https://api.coingecko.com/api/v3/coins/${poolState.baseAssetId}/market_chart"
      params:
        vs_currency: "usd"
        days: "1"
        interval: "hourly"
      output: marketData
      description: "Fetch 24h price data for volatility calculation"

    - name: get_current_pool_state
      type: read_contract
      contract: "${contracts.poolManager}"
      function: "getSlot0"
      args:
        poolKey: "${poolState.poolKey}"
      output: slot0
      description: "Get current pool state (sqrtPriceX96, tick)"

    # ==========================================================================
    # STEP 3: Calculate Pool-Specific Volatility & Strategy
    # ==========================================================================
    - name: calculate_volatility
      type: compute
      language: javascript
      code: |
        // Calculate realized volatility from hourly price data
        const prices = marketData.prices.map(p => p[1]);
        const returns = [];
        for (let i = 1; i < prices.length; i++) {
          returns.push(Math.log(prices[i] / prices[i-1]));
        }
        
        // Annualized volatility in basis points
        const variance = returns.reduce((sum, r) => sum + r * r, 0) / returns.length;
        const hourlyVol = Math.sqrt(variance);
        const annualizedVol = hourlyVol * Math.sqrt(24 * 365);
        const volatilityBps = Math.floor(annualizedVol * 10000);
        
        // Determine risk bucket
        let riskLevel, rangeWidth;
        if (volatilityBps < 2000) {        // < 20% annual vol
          riskLevel = "low";
          rangeWidth = 200;                 // Tight range
        } else if (volatilityBps < 5000) { // 20-50% annual vol
          riskLevel = "medium";
          rangeWidth = 600;                 // Medium range
        } else if (volatilityBps < 10000) { // 50-100% annual vol
          riskLevel = "high";
          rangeWidth = 1500;                // Wide range
        } else {                            // > 100% annual vol
          riskLevel = "extreme";
          rangeWidth = 3000;                // Very wide range
        }
        
        return {
          volatilityBps,
          riskLevel,
          rangeWidth,
          currentPrice: prices[prices.length - 1]
        };
      output: volatilityAnalysis
      description: "Calculate volatility and determine optimal range width"

    # ==========================================================================
    # STEP 4: Calculate Optimal New Range for This Pool
    # ==========================================================================
    - name: calculate_new_range
      type: compute
      language: javascript
      code: |
        const currentTick = slot0.tick;
        const rangeWidth = volatilityAnalysis.rangeWidth;
        const tickSpacing = poolState.tickSpacing || 60;  // Default for 0.3% fee
        
        // Center the range around current tick
        const halfRange = Math.floor(rangeWidth / 2);
        
        // Round to valid tick spacing
        const newTickLower = Math.floor((currentTick - halfRange) / tickSpacing) * tickSpacing;
        const newTickUpper = Math.ceil((currentTick + halfRange) / tickSpacing) * tickSpacing;
        
        // Validate range makes sense
        const actualWidth = newTickUpper - newTickLower;
        const isValidRange = newTickLower < currentTick && currentTick < newTickUpper;
        
        return {
          poolId: trigger.poolId,
          newTickLower,
          newTickUpper,
          currentTick,
          rangeWidth: actualWidth,
          volatility: volatilityAnalysis.volatilityBps,
          riskLevel: volatilityAnalysis.riskLevel,
          isValidRange
        };
      output: newRange
      description: "Calculate new optimal liquidity range centered on current price"

    # ==========================================================================
    # STEP 5: DON Consensus on Rebalancing Parameters
    # ==========================================================================
    - name: report_consensus
      type: consensus
      input:
        poolId: "${newRange.poolId}"
        newTickLower: "${newRange.newTickLower}"
        newTickUpper: "${newRange.newTickUpper}"
        volatility: "${newRange.volatility}"
      threshold: 0.66  # 2/3 of DON nodes must agree
      description: "Decentralized consensus on rebalancing parameters"
      
      # Validation rules applied before consensus
      validation:
        - check: "newRange.isValidRange == true"
          error: "Calculated range is invalid (current tick outside range)"
        - check: "newRange.newTickLower < newRange.currentTick"
          error: "Lower tick must be below current tick"
        - check: "newRange.newTickUpper > newRange.currentTick"
          error: "Upper tick must be above current tick"
        - check: "newRange.rangeWidth >= 100"
          error: "Range too narrow (minimum 100 ticks for gas efficiency)"
        - check: "newRange.rangeWidth <= 5000"
          error: "Range too wide (maximum 5000 ticks for capital efficiency)"

    # ==========================================================================
    # STEP 6: Execute Pool-Specific Rebalancing Transaction
    # ==========================================================================
    - name: execute_rebalance
      type: write_contract
      contract: "${contracts.sentinelHook}"
      function: "maintain"
      args:
        poolId: "${newRange.poolId}"
        newTickLower: "${newRange.newTickLower}"
        newTickUpper: "${newRange.newTickUpper}"
        volatility: "${newRange.volatility}"
      gas_limit: 600000
      condition: "${report_consensus.approved == true}"
      description: "Submit rebalancing transaction to SentinelHook for this specific pool"

    # ==========================================================================
    # STEP 7: Post-Execution Monitoring
    # ==========================================================================
    - name: monitor_execution
      type: event_listener
      events:
        - contract: "${contracts.sentinelHook}"
          event: "LiquidityRebalanced"
          abi:
            - "event LiquidityRebalanced(bytes32 indexed poolId, int24 newTickLower, int24 newTickUpper, uint256 activeAmount, int256 idleAmount)"
          filter:
            poolId: "${newRange.poolId}"
          timeout: 300  # 5 minutes
      description: "Wait for rebalancing confirmation event"

    # ==========================================================================
    # STEP 8: Log Metrics for Analytics
    # ==========================================================================
    - name: log_metrics
      type: webhook
      url: "${env.METRICS_WEBHOOK_URL}"
      method: POST
      body:
        timestamp: "${block.timestamp}"
        blockNumber: "${block.number}"
        poolId: "${newRange.poolId}"
        previousRange:
          tickLower: "${poolState.activeTickLower}"
          tickUpper: "${poolState.activeTickUpper}"
        newRange:
          tickLower: "${newRange.newTickLower}"
          tickUpper: "${newRange.newTickUpper}"
        volatility: "${newRange.volatility}"
        riskLevel: "${volatilityAnalysis.riskLevel}"
        consensusReached: "${report_consensus.approved}"
        executionSuccess: "${monitor_execution.success}"
      description: "Log rebalancing metrics to external analytics"
      condition: "${monitor_execution.success == true}"

# ==============================================================================
# SECONDARY WORKFLOW: SCHEDULED YIELD OPTIMIZATION
# ==============================================================================
yield_optimization:
  name: sentinel-yield-optimizer
  description: Periodic optimization of Active/Idle split across all pools
  
  trigger:
    type: cron
    schedule: "0 */6 * * *"  # Every 6 hours
    description: "Regular yield optimization check"

  steps:
    - name: get_all_pools
      type: read_contract
      contract: "${contracts.sentinelHook}"
      function: "getRegisteredPools"
      output: registeredPools
      description: "Get list of all pools managed by Sentinel"

    - name: check_each_pool
      type: loop
      over: "${registeredPools}"
      as: poolId
      steps:
        - name: get_pool_tvl
          type: read_contract
          contract: "${contracts.sentinelHook}"
          function: "getTotalValueLocked"
          args:
            poolId: "${poolId}"
          output: poolTVL

        - name: get_aave_apy
          type: http_request
          method: GET
          url: "https://api.aave.com/v3/markets/${network.chainId}"
          output: aaveData

        - name: calculate_gas_breakeven
          type: compute
          language: javascript
          code: |
            // Calculate if rebalancing is worth the gas cost
            const tvl = poolTVL.value;
            const currentApy = aaveData.pools.find(p => p.asset == poolState.yieldCurrency)?.apy || 0;
            const estimatedGasCost = 0.01;  // ~$10 in ETH
            const daysToBreakeven = estimatedGasCost / (tvl * currentApy / 365);
            
            return {
              shouldOptimize: daysToBreakeven < 1,  // Only if breakeven < 1 day
              estimatedApy: currentApy,
              tvl
            };
          output: gasAnalysis

        - name: trigger_optimization
          type: conditional_action
          condition: "${gasAnalysis.shouldOptimize == true}"
          action:
            type: emit_event
            event: "YieldOptimizationNeeded"
            args:
              poolId: "${poolId}"
              reason: "APY improved"

# ==============================================================================
# LP EVENT MONITORING (Informational - No Actions)
# ==============================================================================
lp_monitoring:
  name: sentinel-lp-monitor
  description: Monitor LP deposit/withdrawal events for analytics
  
  events:
    - name: lp_deposit
      contract: "${contracts.sentinelHook}"
      event: "LPDeposited"
      abi:
        - "event LPDeposited(bytes32 indexed poolId, address indexed lp, uint256 amount0, uint256 amount1, uint256 shares)"
      action:
        type: webhook
        url: "${env.ANALYTICS_WEBHOOK_URL}"
        body:
          eventType: "deposit"
          poolId: "${event.poolId}"
          lp: "${event.lp}"
          amount0: "${event.amount0}"
          amount1: "${event.amount1}"
          shares: "${event.shares}"
          timestamp: "${block.timestamp}"

    - name: lp_withdraw
      contract: "${contracts.sentinelHook}"
      event: "LPWithdrawn"
      abi:
        - "event LPWithdrawn(bytes32 indexed poolId, address indexed lp, uint256 amount0, uint256 amount1, uint256 shares)"
      action:
        type: webhook
        url: "${env.ANALYTICS_WEBHOOK_URL}"
        body:
          eventType: "withdrawal"
          poolId: "${event.poolId}"
          lp: "${event.lp}"
          amount0: "${event.amount0}"
          amount1: "${event.amount1}"
          shares: "${event.shares}"
          timestamp: "${block.timestamp}"

# ==============================================================================
# ENVIRONMENT VARIABLES (Legacy CRE workflow)
# ==============================================================================
environment:
  METRICS_WEBHOOK_URL: ""      # Analytics endpoint for rebalancing metrics
  ANALYTICS_WEBHOOK_URL: ""    # Analytics endpoint for LP events
  COINGECKO_API_KEY: ""        # Optional: for higher rate limits
